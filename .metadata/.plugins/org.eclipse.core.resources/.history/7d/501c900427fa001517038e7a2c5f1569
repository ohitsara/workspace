/*****************************
 * 
 * @Author: TeamSeis
 * ICS 314: Calendar Maker
 * 
 *****************************/

import java.io.*;
import java.util.*;
 

public class CalendarMaker {
  private final static int          CLASSIFICATION = 1;
  private final static int          LOCATION = 2;
  private final static int          EVENT = 3;
  private final static int          START_TIME = 4;
  private final static int          END_TIME = 5;
  private final static int          DISPLAY_DATA = 6;
  private final static int          MAKE_CALENDAR = 7;
  private final static int          QUIT = 8;

  private boolean                   isPublic;
  private String                    location;
  private String                    event;

  private DateBlock             	eventDate;
  private Scanner                   scanner;

  public static void main(String[] args) {
	  int userChoice = 0;
		final int quit = 2;
		
		Scanner scan = new Scanner(System.in);
		System.out.println("Welcome to Calendar Event Maker");
		System.out.println("[1]Create Event [2]Quit");
		System.out.print("Your Choice:");
		userChoice = scan.nextInt();
		try{
			if(userChoice != quit){
				CalendarMaker myCalendar = new CalendarMaker();
			    myCalendar.start();
			}else
				System.out.println("Thank you for using Calendar Maker.");	
		}catch (InputMismatchException e){
			System.out.println("Error: The choice you entered is not a number.");
			System.exit(1);
		}catch (NoSuchElementException e){
			System.out.println("Error: Invalid Input.");
			System.exit(1);
		}
		scan.close();
	  }

  public CalendarMaker() {
    scanner = new Scanner(System.in);
    isPublic = false;
    location = new String("");
    event = new String("");
    eventDate = new DateBlock();
  }

  public void start() {
    int inputInt = 0;
    boolean test = true;
    while (inputInt != QUIT) {
      System.out.println("(1)Public/Private, (2)Priority, (3)Location, "
          + "(4)Summary, (5)Start, (6)End, (7)Create Free Time, (8)Show Data, "
          + "(9)Make Calendar, (10)Quit");
      try {
        inputInt = Integer.parseInt(scanner.nextLine());
      } catch (Exception e) {
        inputInt = -1;
      }
      test = true;
      switch (inputInt) {
      case CLASSIFICATION:
        test = grabPublic();
        break;
      case LOCATION:
        grabLocation();
        break;
      case EVENT:
        grabSummary();
        break;
      case START_TIME:
        test = grabStart();
        break;
      case END_TIME:
        test = grabEnd();
        break;
      case DISPLAY_DATA:
        showCurrentData();
        break;
      case MAKE_CALENDAR:
        System.out.println("Enter a filename to save data");
        String filename = scanner.nextLine();
        makeCalendar(filename);
        break;
      case QUIT:
        System.out.println("Quitting Program");
        return;
      default:
        System.out.println("Invalid Command");
      }
      if (!test) {
        System.out.println("Invalid Data Entered");
      }
    }
  }

 /* public void createFreeTime(String[] filenames) {
    ArrayList<DateBlock> mDateBlocks = new ArrayList<DateBlock>();
    for (String filename : filenames) {
      if (validFile(filename)) {
        File file = new File(filename);
        Scanner fileScanner = null;
        try {
          fileScanner = new Scanner(file);
        } catch (Exception e) {
        }
        String start = null;
        String end = null;
        // parse .ics for DTSTART and DTEND and init objects
        while (fileScanner.hasNext()) {
          String[] splitLine = fileScanner.nextLine().split(":");
          if (stringMatch(splitLine[0], "DTSTART"))
            start = splitLine[1];
          if (stringMatch(splitLine[0], "DTEND"))
            end = splitLine[1];
        }
        // if the .ics file has proper DTSTART and DTEND
        if (start != null && end != null) {
          DateBlock block = new DateBlock(start, end);
          block.getStartTime().show();
          block.getEndTime().show();
          // all date blocks must be on the same day, only add if they are
          if (mDateBlocks.isEmpty() || (!mDateBlocks.isEmpty() && 
              DateData.isSameDate(mDateBlocks.get(0).getStartTime(), block.getStartTime()))) {
            mDateBlocks.add(block);
          }
        }
      }
    }
    if (mDateBlocks.size() == 0) {
      return;
    }
    int year = mDateBlocks.get(0).getStartTime().getCal().get(Calendar.YEAR);
    // add one because cal.get(Calendar.MONTH) starts at 0 for jan
    int month = mDateBlocks.get(0).getStartTime().getCal().get(Calendar.MONTH) + 1;
    int day = mDateBlocks.get(0).getStartTime().getCal()
        .get(Calendar.DAY_OF_MONTH);
    mDateBlocks.add(new DateBlock(new DateData(year, month, day, 0, 0, 0),
        new DateData(year, month, day, 0, 0, 0)));
    mDateBlocks.add(new DateBlock(
        new DateData(year, month, day, 23, 59, 59), new DateData(year, month,
            day, 23, 59, 59)));
    Collections.sort(mDateBlocks);
    mSummary = "Free Time";
    for (int i = 1; i < mDateBlocks.size(); i++) {
      DateBlock temp = DateBlock.difference(mDateBlocks.get(i-1), 
          mDateBlocks.get(i));
      if (temp != null) {
        mDateBlock = temp;
        makeCalendar(Integer.toString(i) + ".ics");
      }
    }
  }*/

  public boolean grabPublic() {
    System.out.println("(1)Public or (2)Private?");
    int inputInt = Integer.parseInt(scanner.nextLine());
    if (inputInt != 1 && inputInt != 2)
      return false;
    if (inputInt == 1) {
      isPublic = true;
    } else {
      isPublic = false;
    }
    return true;
  }
  
  public void grabLocation() {
    System.out.println("Enter a Location");
    location = scanner.nextLine();
  }

  public void grabSummary() {
    System.out.println("Enter a Summary");
    event = scanner.nextLine();
  }

  public boolean grabStart() {
    System.out.println("------StartTime------");
    return eventDate.getStartTime().grab();
  }

  public boolean grabEnd() {
    System.out.println("-------EndTime-------");
    return eventDate.getEndTime().grab();
  }

  public void showCurrentData() {
    System.out.println("Calendar Information:");
    showPublic();
    showPriority();
    showLocation();
    showSummary();
    showStartTime();
    showEndTime();
  }

  public void showPublic() {
    System.out.println("Public: " + Boolean.toString(isPublic));
  }
  public void showLocation() {
    System.out.println("Location: " + location);
  }

  public void showSummary() {
    System.out.println("Summary: " + summary);
  }

  public void showStartTime() {
    System.out.println("------StartTime------");
    eventDate.getStartTime().show();
    System.out.println("---------------------");
  }

  public void showEndTime() {
    System.out.println("-------EndTime-------");
    eventDate.getEndTime().show();
    System.out.println("---------------------");
  }

  public void makeCalendar(String filename) {
    PrintWriter writer = null;
    try {
      writer = new PrintWriter(filename, "UTF-8");
    } catch (Exception e) {
      e.printStackTrace();
      System.out.println("Error with file name");
      return;
    }
    writer.println("BEGIN:VCALENDAR");
    writer.println("VERSION:2.0");
    writer.println("BEGIN:VEVENT");
    if (isPublic) {
      writer.println("CLASS:PUBLIC");
    } else {
      writer.println("CLASS:PRIVATE");
    }
    writer.println("LOCATION:" + location);
    writer.println("SUMMARY:" + event);
    writer.println("DTSTART;TZID=Pacific/Honolulu:"
        + eventDate.getStartTime().format());
    writer.println("DTEND;TZID=Pacific/Honolulu:"
        + eventDate.getEndTime().format());
    writer.println("END:VEVENT");
    writer.println("END:VCALENDAR");
    System.out.println("Finished Creating File");
    writer.close();
  }

  private boolean validFile(String filename) {
    File file = new File(filename);
    if (file.exists() && !file.isDirectory())
      return true;
    return false;
  }

  private boolean stringMatch(String string, String pattern) {
    if (string.isEmpty() || pattern.isEmpty()
        || pattern.length() > string.length())
      return false;
    for (int i = 0; i < pattern.length(); i++) {
      if (string.charAt(i) != pattern.charAt(i))
        return false;
    }
    return true;
  }

}
